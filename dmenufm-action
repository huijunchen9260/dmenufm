#!/bin/sh

FM_Action () { # Usage: FM_Action
    move=$(printf '%s\n' "$ACTLIST" | yprompt "Actions:" "$FM_GENERIC_COLOR")
    case $move in
	"$FM_PCP") FM_PCP ;;
	"$FM_NEW") FM_NEW ;;
	"$FM_MVV"|"$FM_YAK"|"$FM_LNK") FM_MYL ;;
	"$FM_REM") FM_REM ;;
	"$FM_DEL") FM_DEL ;;
	"$FM_TRH") FM_TRH ;;
	"$FM_HIS") FM_HIS ;;
	"$FM_BMK") FM_BMK ;;
	"$FM_CMD") FM_CMD ;;
	"$FM_ZIP") FM_ZIP ;;
	"$FM_SDO") FM_SDO ;;
	"$FM_EYE") FM_EYE ;;
    esac
    MainMenu
}

BulkListAll () { # Usage: BulkListAll
    SELECTED=$(printf '%s' "$list" | sed "/^$/ d; s=^=$PWD/=g")
    [ -n "$SELECTED" ] && check=$(printf '%s' "$SELECTED" | yprompt "Check selections. (Enter to continue, ESC to quit)" "$FM_ACTION_COLOR_LV1")
}


BulkListMass () { # Usage: BulkListMass
    SELECTED=$(printf '%s' "$list" | sed "/^$/ d; s=^=$PWD/=g")
    [ -f "$FM_MASFILE" ] && rm "$FM_MASFILE"

    printf '%s\n' "$SELECTED" | sed "s=/$==g; /^$/ d" > "$FM_MASFILE"
    NotiPrompt "Remove unwanted names and remain the desire ones."
    FileOpen "$FM_MASFILE"

    SELECTED="$(cat -u $FM_MASFILE | sed "/^$/ d")"
    [ -n "$SELECTED" ] && check=$(printf '%s' "$SELECTED" | yprompt "Check selections. (Enter to continue, ESC to quit)" "$FM_ACTION_COLOR_LV1")

    rm "$FM_MASFILE"
}

BulkMode () { # Usage: BulkMode [MSG]
    HERE=""
    bulklist=""
    ActionMenu "$1" "$FM_ACTION_COLOR_BULK" || return && allowbulk="NotAllowed"

    while [ "$bulkselection" = "true" ]; do
	ActionMenu "$1" "$FM_ACTION_COLOR_BULK" || return && allowbulk="NotAllowed"
	HERE=$bulklist
	allowbulk="NotAllowed"
    done

    SELECTED=$(printf '%s' "$HERE" | uniq)
    allowbulk="NotAllowed"

    if [ "$actCHOICE" = "$ENDSELECTION" ] && [ -n "$SELECTED" ]; then
	check=$(printf '%s' "$SELECTED" | sed "/^$/ d" | yprompt "Check selections. (Enter to continue, ESC to quit) " "$FM_ACTION_COLOR_LV1")
    fi
}


FM_BMK () { # Usage: FM_BMK
    markmenu=$(printf '%s\n' "$(cat -u "$FM_BMKFILE")" "Add BMK" "Delete BMK" | yprompt "Dmenufm Bookmark" "$FM_GENERIC_COLOR")
    # Add \n at end of file
    if [ "$(tail -c 1 "$FM_BMKFILE")" != "" ]; then
	echo >> "$FM_BMKFILE"
    fi
    case "$markmenu" in
	"Add BMK")
	    ActionMenu "Choose file / directory and add to BMK: " "$FM_ACTION_COLOR_LV1" || return
	    mark=${HERE##*/}
	    if [ -n "$mark" ]; then
		printf '%s' "$mark - $HERE" >> "$FM_BMKFILE" && NotiPrompt "$mark added."
	    fi
	    ;;
	"Delete BMK")
	    BMK="$(cat -u "$FM_BMKFILE")"
	    delbmk=$(< "$FM_BMKFILE" yprompt "Delete chosen bookmark: " "darkred") || return
	    if [ -n "$delbmk" ]; then
		printf '%s' "${BMK%%$nl"$delbmk"*}" "${BMK##*"$delbmk"}" > "$FM_BMKFILE" && NotiPrompt "$delbmk deleted"
	    fi
	    ;;
	*)
	    destination=${markmenu##* - }

	    if [ -n "$destination" ] && [ "$termpath" = "true" ]; then
		printf '%s' "$destination"
		exit 0
	    elif [ -n "$destination" ]; then
		cd "$destination" || FileOpen "$destination"
	    fi
	    ;;
    esac
}

BulkCMD () { # Usage: BulkCMD
    execfile=$(printf '%s' "$SELECTED")
    execmd=$(printf '%s' "$execmd" | sed "1 s/$.*//")
    IFS="$nl"
    for selection in $(printf '%s' "$execfile"); do
	unset IFS
	$execmd "$selection"
    done && NotiPrompt "Command executed on selected."
}

ExecCMD () { # Usage: ExecCMD [CMD]
    software=$(printf '%s' "${1%% *}")
    appdesktop=$(find "$XDGDIR1" "$XDGDIR2" -name "*$software*.desktop" | tail -n 1)
    if [ -n "$appdesktop" ] && grep 'Terminal=false' "$appdesktop"; then
	printf '%s' "$1" | ${SHELL:-"/bin/sh"}
    else
	$TERMINAL -e $1 | ${SHELL:-"/bin/sh"}
    fi
}

FM_CMD () { # Usage: FM_CMD
    cmdmenu=$(printf '%s\n' "$(cat -u "$FM_CMDFILE")" "Add CMD" "Delete CMD" | yprompt "Dmenufm Custom Command" "$FM_GENERIC_COLOR")
    # Add \n at end of file
    if [ "$(tail -c 1 "$FM_CMDFILE")" != "" ]; then
	echo >> "$FM_CMDFILE"
    fi
    case "$cmdmenu" in
	"Add CMD")
	    addcmd=$(xprompt "Recording your command: " "$FM_ACTION_COLOR_LV1") || return
	    desp=$(xprompt "Enter command description: " "$FM_ACTION_COLOR_LV1") || return
	    if [ -n "$addcmd" ]; then
		printf '%s' "$addcmd - $desp" >> "$FM_CMDFILE" && NotiPrompt "$addcmd added."
	    fi
	    ;;
	"Delete CMD")
	    CMD="$(cat -u "$FM_CMDFILE")"
	    delcmd=$(< "$FM_CMDFILE" yprompt "Delete chosen command: " "darkred")
	    if [ -n "$delcmd" ]; then
		printf '%s' "${CMD%%$nl"$delcmd"*}" "${CMD##*"$delcmd"}" > "$FM_CMDFILE" && NotiPrompt "$delcmd deleted"
	    fi
	    ;;
	*)
	    execmd=${cmdmenu%% - *}
	    if printf '%s' "$execmd" | grep '\$'; then
		allowbulk="Bulk Execute"
		allselection="Bulk Execute All"
		masselection="Bulk Execute Mass"
		ActionMenu "Choose and execute: " "$FM_ACTION_COLOR_LV1"
		if [ "$bulkselection" = "true" ]; then
		    BulkMode "Select to execute: "
		    [ -n "$check" ] && BulkCMD
		elif [ "$actCHOICE" = "$allselection" ]; then
		    BulkListAll
		    [ -n "$check" ] && BulkCMD
		elif [ "$actCHOICE" = "$masselection" ]; then
		    BulkListMass
		    [ -n "$check" ] && BulkCMD
		else
		    SELECTED="$HERE"
		    BulkCMD
		fi
	    else
		ExecCMD "$execmd"
	    fi
	    ;;
    esac
}

DangerMenu () { # Usage: DangerMenu [CMD] [MSG] (OPT: [Dest])
    IFS="$nl"
    if DangerPrompt "$2"; then
	for selection in $(printf '%s' "$SELECTED"); do
	    unset IFS
	    if [ -z "$destination" ]; then
		$1 "$selection"
	    else
		$1 "$selection" "$3"
	    fi
	done && NotiPrompt "Selected removed."
    fi
}

FM_DEL () { # Usage: FM_DEL
    allowbulk="Bulk Delete"
    allselection="Bulk Delete All"
    masselection="Bulk Delete Mass"
    ActionMenu "Remove file / directory: " "$FM_ACTION_COLOR_LV1" || return && allowbulk="NotAllowed"
    if [ "$bulkselection" = "true" ]; then
	BulkMode "Select files / directories to delete: "
	[ -n "$check" ] && DangerMenu "rm -rf" "Delete all selected?" ""
    elif [ "$actCHOICE" = "$allselection" ]; then
	BulkListAll
	[ -n "$check" ] && DangerMenu "rm -rf" "Delete all selected in $name?" ""
    elif [ "$actCHOICE" = "$masselection" ]; then
	BulkListMass
	[ -n "$check" ] && DangerMenu "rm -rf" "Delete all selected in $name?" ""
    else
	# Single-selection mode
	allowbulk="NotAllowed"
	# Check the chosen on is directory or not
	[ -n "$HERE" ] && [ -d "$HERE" ] && result=$?
	[ -n "$HERE" ] && SELECTED="$HERE" && DangerMenu "rm -rf" "Remove all the files / directories in $name?" ""
	if [ "$result" -eq 0 ] && [ "$rollingmenu" = "true" ]; then
	    rollmenu=""
	    cd "../" && result=""
	    rolldir="$PWD"
	elif [ "$result" -eq 0 ]; then
	    cd "../" && result=""
	else
	    result=""
	fi
    fi
}

History () { # Usage: History
    dirmark="${PWD##*/}"
    printf '%s\n' "$dirmark - $PWD" >> "$FM_HISFILE"
    # Limit the max number of history
    TMP=$(wc -l "$FM_HISFILE")
    hisnum=${TMP%% *}
    unset TMP
    if [ "$hisnum" -ge "$FM_MAX_HIS_LENGTH" ]; then
	# newline="$(printf '\n ')" && newline="${newline% }"
	HIS="$(cat -u $FM_HISFILE)"
	printf '%s\n' "${HIS#*"$nl"}" > "$FM_HISFILE"
    fi
}

FM_HIS () { # Usage: FM_HIS
    # Use sed command to mimic reverse of cat for POSIX.
    goto=$(sed '1!G;h;$!d' "$FM_HISFILE" | yprompt "Dmenufm History" "$FM_GENERIC_COLOR")
    destination=${goto##* - }
    cd "$destination" || return
}

DestMenu () { # Usage: DestMenu
    ActionMenu "Destination: " "$FM_ACTION_COLOR_LV2" || return && allowbulk="NotAllowed" && actCHOICE="placeholder"
    [ -n "$HERE" ] && destination="$HERE" && destname="$name"
    if [ -n "$HERE" ]; then
	IFS="$nl"
	for selection in $(printf '%s' "$SELECTED"); do
	    unset IFS
	    $cmd "$selection" "$destination"
	done && NotiPrompt "Selected files / directories $cmdname to $destname"
    fi
}

FM_MYL () { # Usage: FM_MYL
    case "$move" in
	"$FM_MVV")
	    cmd="mv"
	    cmdname="moved"
	    cmdverb="move"
	    allowbulk="Bulk Move"
	    allselection="Bulk Move All"
	    masselection="Bulk Move Mass"
	    ;;
	"$FM_YAK")
	    cmd="cp -R"
	    cmdname="copied"
	    cmdverb="copy"
	    allowbulk="Bulk Copy"
	    allselection="Bulk Copy All"
	    masselection="Bulk Copy Mass"
	    ;;
	"$FM_LNK")
	    cmd="ln -s"
	    cmdname="linked"
	    cmdverb="link"
	    allowbulk="Bulk Link"
	    allselection="Bulk Link All"
	    masselection="Bulk Link Mass"
	    ;;
    esac
    ActionMenu "Source: " "$FM_ACTION_COLOR_LV1" || return && allowbulk="NotAllowed"
    if [ "$bulkselection" = "true" ]; then
	BulkMode "Select files / directories to $cmdverb: "
	[ -n "$check" ] && DestMenu
    elif [ "$actCHOICE" = "$allselection" ]; then
	BulkListAll
	[ -n "$check" ] && DestMenu
    elif [ "$actCHOICE" = "$masselection" ]; then
	BulkListMass
	[ -n "$check" ] && DestMenu
    else
	# Single-selection mode
	[ -n "$HERE" ] && SELECTED="$HERE"
	[ -d "$SELECTED" ] && cd "../"
	[ -n "$SELECTED" ] && DestMenu
    fi
}

NewFileDir () { # Usage: NewFileDir
    name=$(xprompt "Type name for $newmenu; Press ESC to leave" "$FM_ACTION_COLOR_LV1") || return
    case "$name" in
	'~') NotiPrompt "Alias to $HOME; not a proper name." && continue ;;
	'/') NotiPrompt "Alias to root; not a proper name." && continue ;;
	':') NotiPrompt "Alias for Command prompt; not a proper name." && continue ;;
	'.') NotiPrompt "Alias for current directory; not a proper name." && continue ;;
	'..') NotiPrompt "Alias for parent directory; not a proper name." && continue ;;
	'*'|'!'|'?'|'+'|'['|']'|'^'|'$'|'{'|'}'|'-'|'('|')'|'|'|'\') NotiPrompt "Shell pattern; not a proper name." && FM_NEW ;;
	*) $cmd "$name" ;;
    esac
}

FM_NEW () { # Usage: FM_NEW
    name="placeholder"
    newmenu=$(printf '%s\n' "File" "Directory" | yprompt "Create new files or directories" "$FM_GENERIC_COLOR")
    while [ -n "$name" ]; do
	if [ "$newmenu" = "File" ]; then
	    cmd='touch'
	    NewFileDir
	else
	    cmd="mkdir -p"
	    NewFileDir
	fi
    done
}

FM_PCP () { # Usage: FM_PCP
    # Copy path to xclip, and send notification.
    ActionMenu "Copy file / directory path: " "$FM_ACTION_COLOR_LV1" || return
    if [ -n "$HERE" ] && command -v xclip; then
	printf '%s' "$HERE" | xclip -selection clipboard && NotiPrompt "Path $name copied to clipboard."
    elif [ -n "$HERE" ] && command -v xsel; then
	printf '%s' "$HERE" | xsel --clipboard && NotiPrompt "Path $name copied to clipboard."
    elif [ -n "$HERE" ]; then
	NotiPrompt "Need to install xclip or xsel as dependency"
    else
	continue
    fi
}

BulkRename () { # Usage: BulkRename
    if [ -n "$SELECTED" ]; then
	[ -f "$FM_REMFILE" ] && rm "$FM_REMFILE" "$FM_REMFILE.dirname" "$FM_REMFILE.backup"

	printf '%s\n' "$SELECTED" | sed "s=/$==g; /^$/ d" > "$FM_REMFILE.backup"

	IFS="$nl"
	while read -r line; do
	     printf '%s\n' "${line##*/}" >> "$FM_REMFILE"
	done < "$FM_REMFILE.backup"
	while read -r line; do
	    printf '%s\n' "${line%%/"${line##*/}"}" >> "$FM_REMFILE.dirname"
	    unset TMP
	done < "$FM_REMFILE.backup"
	unset IFS

	FileOpen "$FM_REMFILE"

	if [ "$(wc -l < "$FM_REMFILE" )" -ne "$(wc -l < "$FM_REMFILE.backup")" ]; then
	    NotiPrompt "ERROR: Lines mismatch in rename file; do nothing." && return
	else
	    renamevar=$(paste -d ':' "$FM_REMFILE.backup" "$FM_REMFILE.dirname" "$FM_REMFILE")
	    # Set IFS for for loop as \n
	    IFS="$nl"
	    for selection in $(printf '%s' "$renamevar"); do
		TMP="${selection%%:"${selection##*:}"}"
		start="${TMP%%:"${TMP##*:}"}"
		destination="${TMP##*:}/${selection##*:}"
		unset TMP
		if [ "$start" = "$destination" ]; then
		    continue
		else
		    mv "$start" "$destination"
		fi
	    done && NotiPrompt "Selected renamed"
	    unset IFS
	fi
	rm "$FM_REMFILE" "$FM_REMFILE.dirname" "$FM_REMFILE.backup"
    else
	return
    fi
}

FM_REM () { # Usage: FM_REM
    allowbulk="Bulk Rename"
    allselection="Bulk Rename All"
    masselection="Bulk Rename Mass"
    ActionMenu "Source: " "$FM_ACTION_COLOR_LV1" || return && allowbulk="NotAllowed"
    if [ "$bulkselection" = "true" ]; then
	BulkMode "Select files / directories to rename: "
	[ -n "$check" ] && BulkRename
    elif [ "$actCHOICE" = "$allselection" ]; then
	BulkListAll
	[ -n "$check" ] && BulkRename
    elif [ "$actCHOICE" = "$masselection" ]; then
	BulkListMass
	[ -n "$check" ] && BulkRename
    else
	[ -n "$HERE" ] && [ -d "$HERE" ] && result=$?
	SELECTED="$HERE"
	[ -n "$SELECTED" ] && BulkRename
	if [ "$result" -eq 0 ] && [ "$rollingmenu" = "true" ]; then
	    rollmenu=""
	    cd "../" && result=""
	    rolldir="$PWD"
	elif [ "$result" -eq 0 ]; then
	    cd "../" && result=""
	else
	    result=""
	fi
    fi
}

DangerMenu () { # Usage: DangerMenu [CMD] [MSG] (OPT: [Dest])
    IFS="$nl"
    if DangerPrompt "$2"; then
	for selection in $(printf '%s' "$SELECTED"); do
	    unset IFS
	    if [ -z "$destination" ]; then
		$1 "$selection"
	    else
		$1 "$selection" "$3"
	    fi
	done && NotiPrompt "Selected removed."
    fi
}

FM_TRH () { # Usage: FM_TRH
    allowbulk="Bulk Trash"
    allselection="Bulk Trash All"
    masselection="Bulk Trash Mass"
    trashmenu=$(printf '%s\n' "Move to trash" "Go to trash" "Empty trash" | yprompt "Dmenufm Trash" "$FM_GENERIC_COLOR")
    case $trashmenu in
	"Move to trash")
	    ActionMenu "Move file / directory to trash: " "$FM_ACTION_COLOR_LV1" || return && allowbulk="NotAllowed"
	    if [ "$bulkselection" = "true" ]; then
		BulkMode "Select files / directories to move to trash: "
		[ -n "$check" ] && DangerMenu "mv" "Move all selected to trash?" "$FM_TRASH"
	    elif [ "$actCHOICE" = "$allselection" ]; then
		BulkListAll
		[ -n "$check" ] && DangerMenu "mv" "Move all selected to trash?" "$FM_TRASH"
	    elif [ "$actCHOICE" = "$masselection" ]; then
		BulkListMass
		[ -n "$check" ] && DangerMenu "mv" "Move all selected to trash?" "$FM_TRASH"
	    else
		allowbulk="NotAllowed"
		# Check the chosen on is directory or not
		[ -n "$HERE" ] && [ -d "$HERE" ] && result=$?
		[ -n "$HERE" ] && SELECTED="$HERE" && DangerMenu "mv" "Move $name to trash?" "$FM_TRASH"
		if [ "$result" -eq 0 ] && [ "$rollingmenu" = "true" ]; then
		    rollmenu=""
		    cd "../" && result=""
		    rolldir="$PWD"
		elif [ "$result" -eq 0 ]; then
		    cd "../" && result=""
		else
		    result=""
		fi
	    fi
	    ;;
	"Go to trash")
	    cd "$FM_TRASH" || return
	    ;;
	"Empty trash")
	    # Lesson: You cannot quote a wildcard. No quote on *.
	    if DangerPrompt "Remove all files and/or directory in trash?" && rm -rf "$FM_TRASH"/*; then
		NotiPrompt "Trash is empty." || return
	    else
		return
	    fi
	    ;;
    esac
}

BulkCompress () { # Usage: BulkCompress
    case $compression_type in
	"tar.gz") cmd="tar -czvf" ;;
	"tar.xz") cmd="tar -cJvf" ;;
	"tar.bz2") cmd="tar -cjvf" ;;
	"gz") cmd="gzip -k" ;;
	"bz2") cmd="bzip2 -k" ;;
	"xz") cmd="xz -k" ;;
	"lzma") cmd="lzma -k" ;;
	"7z") cmd="7z a" ;;
	"zip") cmd="zip -r" ;;
	*) return ;;
    esac
    if echo "$compression_type" | grep -E '^tar|^zip'; then
	[ -d "$FM_ZIPATH" ] && rm -rf "$FM_ZIPATH"
	mkdir "$FM_ZIPATH"
	IFS="$nl"
	for file in $SELECTED; do
	    unset IFS
	    cp -R "$file" "$FM_ZIPATH"
	done
	archive_name=$(xprompt "Please insert archive name: " "$FM_ACTION_COLOR_LV2" | cut -d '.' -f1) || return
	if [ -n "$archive_name" ]; then
	    compressdir_name="$archive_name"
	    archive_name="$archive_name.$compression_type"
	    mv "$FM_ZIPATH" "./$compressdir_name"
	    $cmd "$archive_name" ./"$compressdir_name"/* && NotiPrompt "Compressed to $archive_name"
	    rm -rf ./"$compressdir_name"
	fi
	rm -rf "$FM_ZIPATH"
    else
	IFS="$nl"
	for file in $SELECTED; do
	    unset IFS
	    $cmd "$file" && NotiPrompt "Compressed to ${file##*/}"
	done
    fi
}


FM_ZIP () { # Usage: FM_ZIP
    allowbulk="Bulk Compress"
    allselection="Bulk Compress All"
    masselection="Bulk Compress Mass"
    compression_type=$(printf '%s\n' "$COMPRESSIONLIST" | yprompt "Compression type: " "$FM_ACTION_COLOR_LV1" || return && allowbulk="NotAllowed")
    if ! printf '%s' "$compression_type" | grep -E '^tar|^zip'; then
	allowbulk="NotAllowed"
    fi
    [ -n "$compression_type" ] && ActionMenu "Source: " "$FM_ACTION_COLOR_LV1" || return && allowbulk="NotAllowed"
    if [ "$bulkselection" = "true" ]; then
	BulkMode "Select files / directories to compress: "
	[ -n "$check" ] && BulkCompress
    elif [ "$actCHOICE" = "$allselection" ]; then
	BulkListAll
	[ -n "$check" ] && BulkCompress
    elif [ "$actCHOICE" = "$masselection" ]; then
	BulkListMass
	[ -n "$check" ] && BulkCompress
    else
	SELECTED="$HERE"
	[ -n "$SELECTED" ] && BulkCompress
    fi
}

FM_SDO () {
    sudo -A dmenufm
}

# FM_EYE () {
#     preview="true"

#     yprompt () { # Usage yprompt [MSG] [BG_COLOR]
# 	dmenu -f -fn "$FM_GENERIC_FONT" -b -i -h 40 -sb "$2" -p "$1"
#     }

#     ActionMenu "Preview mode: " "$FM_ACTION_COLOR_LV1" || return && allowbulk="NotAllowed"
#     [ -n "$HERE" ] && FileOpen "$HERE" &
#     while [ -n "$HERE" ]; do
# 	wmctrl -r :ACTIVE: -N "PREVIEW"
# 	ActionMenu "Preview mode: " "$FM_ACTION_COLOR_LV1" || return && allowbulk="NotAllowed"
# 	[ -n "$HERE" ] && FileOpen "$HERE" &
# 	wmctrl -c "PREVIEW"
#     done
#     wmctrl -c :ACTIVE:

#     yprompt () { # Usage yprompt [MSG] [BG_COLOR]
# 	dmenu -f -fn "$FM_GENERIC_FONT" -i -sb "$2" -l 10 -p "$1"
#     }

#     preview="false"
# }


FM_EYE () {
    preview="true"

    yprompt () { # Usage yprompt [MSG] [BG_COLOR]
	dmenu -f -fn "$FM_GENERIC_FONT" -b -i -sb "$2" -p "$1"
    }

    ActionMenu "Preview mode: " "$FM_ACTION_COLOR_LV1" || return && allowbulk="NotAllowed"
    [ -n "$HERE" ] && FileOpen "$HERE" &
    while [ -n "$HERE" ]; do
	wmctrl -ic "$eyeid" &
	ActionMenu "Preview mode: " "$FM_ACTION_COLOR_LV1" || return && allowbulk="NotAllowed"
	eyeid="$(xprop -root _NET_ACTIVE_WINDOW | cut -d ' ' -f 5)"
	[ -n "$HERE" ] && FileOpen "$HERE" &
    done
    wmctrl -ic "$eyeid"

    yprompt () { # Usage yprompt [MSG] [BG_COLOR]
	dmenu -f -fn "$FM_GENERIC_FONT" -i -sb "$2" -l 10 -p "$1"
    }

    preview="false"
}

